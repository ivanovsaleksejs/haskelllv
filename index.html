<html>
<head>
    <meta charset="utf-8">
    <title>haskell.lv</title>
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="/index.css">
</head>
<body>
    <div class="header">
        <div class="nav">
           <a href="/">Apmācība</a>
           <a href="https://www.haskell.org/downloads" target="_blank">Lejuplādēt</a>
           <a href="/irc.html">IRC</a>
           <a href="/news.html">Ziņas</a>
           <a href="/links.html">Saites uz citiem resursiem</a>
        </div>
    </div>
    <h1>Apmācība</h1>
    <div class="content">
        <div class="tutorial">
            <div id="prev" class="slide-button inactive"><</div>
            <div id="next" class="slide-button">></div>
            <div class="wrapper">
                <div class="slide">
                    <h2>Par šo apmācību</h2>
                    <p class="intro">Šī ampācība ir domāta cilvēkiem, kas vēlas apgūt Haskell programmēšanas valodu. Apmācība, pirmkārt, ir domāta tiem, kas jau māk programmēt citās valodās. Bet, ja Jums nav pieredzes programmēšanā vai kaut kāds termins nav saprotams, tad Jūs varat uzbraukt ar peli uz pasvītrotajiem terminiem un izlasīt definīciju.</p>
                    <h2>Kas ir Haskell</h2>
                    <p>Haskell ir <u id="functional" class="def">funkcionāla</u> valoda, kurai piemīt vairākas īpašības, kas izceļ to citu programmēšanas valodu starpā. Tā ir <u id="pure" class="def">tīri funkcionāla</u>, bet tajā paša laikā ļauj viegli rakstīt <u id="imperative" class="def">imperatīvu</u> kodu. Tai ir ļoti attīstīta <u id="type" class="def">tipu</u> sistēma, kas ļauj izvairīties no daudzām kļūdām. Tai ir diezgan daudz sintakses iespēju, kas ļauj rakstīt lakonisku un saprotamu kodu.</p>
                </div>
                <div class="slide">
                    <h2>Mīti par Haskell</h2>
                    <p>Haskell ir viena no populārākajām funkcionālajām valodām. Ir diezgan daudz cilvēku, kas māk rakstīt kodu ar Haskell (diemžēl, Latvijā tādu cilvēku joprojām ir maz). Bet vēl vairāk ir cilvēku, kas par Haskell ir dzirdējuši visādus mītus un turpina tos izplatīt. Šeit es apkopošu tos mītus un paskaidrošu, kāpēc tie ir tikai mīti.</p>
                    <h2>Lai apgūtu Haskell, ir vajadzīgas augstākās matemātikas zināšanas</h2>
                    <p>Haskell izmanto dažus kategoriju teorijas principus un ir mantojis terminus no tās. Bet kategoriju teoriju nav jāzina, lai varētu apgūt Haskell. Otrādi - ja cilvēks ir apgūvis Haskell, var teikt, ka viņš ir apguvis kategoriju teorijas pamatus.</p>
                    <h2>Haskell ir grūta valoda</h2>
                    <p>Haskell ir diezgan vienkārša valoda. Tajā ir ļoti maz elementu, mazāk nekā <u id="oop" class="def">OOP</u> valodās. Sākumā ir grūti pierast pie valodas lakoniskuma, pie dažu <u id="boilerplate">boilerplate</u> elementu neesamības. Bet pie tā pierod pāris dienu laikā.</p>
                </div>
                <div class="slide">
                    <h2>Mīti par Haskell</h2>
                    <h2>Ar Haskell ir grūti uzrakstīt lietojamu kodu</h2>
                    <p>Cilvēkiem, kuri nāk no OOP pasaules, ir grūti pierast pie tā, ka Haskellā nepastāv mainīgie un stāvoklis. Kad cilvēks sakrāj pieredzi un iemācās pareizi strukturēt kodu, viņš saprot, kāpēc stāvoklis ir tas, kas veicina kļūdas programmas izpildes laikā. Savukārt stāvoklis Haskell programmās ir iegūstams ar speciāliem datu tipiem.</p>
                    <h2>Haskell zināšanas ir bezjēdzīgas, jo nevar atrast darbu</h2>
                    <p>Haskell nav izplatīts Latvijā, bet mūsdienās programmētājiem attālums nav šķērslis, un par Haskell darbiem ārzemnieki ir gatavi maksāt diezgan lielu naudu. Kā arī, Haskell apgūšana maina programmētāja domāšanu un atver pavisam citādāku skatu uz programmēšanu.</p>
                </div>
                <div class="slide">
                    <h2>Daži koda piemēri</h2>
                    <pre>a = 2 + 3</pre>
                    <p>a saturēs 5.</p>
                    <pre>
list = [1,2,3,4,5]

anotherList = [1..10]</pre>
                    <p>Tiek izveidoti 2 saraksti, viens ar skaitļiem no 1 līdz 5, otrs - no 1 līdz 10.</p>
                    <pre>toUpper 'a'</pre>
                    <p>Atgriež 'A'.</p>
                </div>
                <div class="slide">
                    <h2>Funkcijas</h2>
                    <p>Haskell valodas galvenais elements ir funkcijas. Funkciju definīcija arī ir īsa un lakoniska:</p>
                    <pre>cube x = x ^ 3</pre>
                    <p>Kā var redzēt, Haskell neprasa nekādu funkcijas atslēgvārdu, piemēram, function vai def. Tas tiek panākts ar to, ka funkcijas ir valodas pamatelements.</p>
                    <p>Funkcijas argumenti tiek padoti pēc funkcijas nosaukuma ar atstarpi, piemēram:</p>
                    <pre>triangleArea a h = a * h / 2</pre>
                </div>
                <div class="slide">
                    <h2>Programmas</h2>
                    <p>Haskell programmas ir ļoti lakoniskas un satur ļoti maz boilerplate:</p>
                    <pre>
cube x = x ^ 3

main = print (cube 4)</pre>
                    <p>Un pat šo programmu var padarīt īsāku. Ja mēs skatāmies uz funkciju cube, tad viss, ko tā dara - kāpina argumentu trešajā pakāpē. Mums šajā situācijā ir vienalga, kāds ir arguments, mums ir svarīgi, ko funkcija dara. Tāpēc pierakstīsim to citādāk:<p>
                    <pre>cube = (^3)</pre>
                    <p>Izmantojot šo pieeju, kods var sanākt ļoti tīrs un daudz lasāmāks.</p>
                </div>
                <div class="slide">
                    <h2>Kā iesākt</h2>
                    <p>Iesācējiem ir rekomendēts uzinstalēt haskell-platform. Tas iekļauj sevī GHC <u id="compiler" class="def">kompilātoru</u>, Cabal paku menedžeri un dažas izplatītas pakas.</p>
                    <p>Lai instalētu vajadzīgās pakas, var izmantot komandu <pre>cabal install package_name</pre></p>
                    <p>Ir noderīgi apgūt arī interaktīvo interpretatoru, ghci.</p>
                </div>
                <div class="slide">
                    <h2>Pirmā programma</h2>
                    <p>Izveidojiet failu hello.hs un ierakstiet šo kodu:</p>
                    <pre>main = print "Hello world!"</pre>
                    <p>Sakompilējiet to ar</p>
                    <pre>ghc hello.hs</pre>
                    <p>Jūs redzēsiet paziņojumus:</p>
                    <pre>
[1 of 1] Compiling Main             ( hello.hs, hello.o )
Linking hello ...</pre>
                    <p>Sakompilēto programmu var palaist ar <pre>./hello</pre></p>
                </div>
                <div class="slide">
                    <h2>Tipi</h2>
                    <p>Haskell tipu sistēma ir ļoti advancēta un dara ļoti daudz darba, lai nodrošinātu programmas stabilitāti. Bet sākumā ir nepieciešams saprast, kā Haskell funkcijām tiek aprakstīti tipi. Paņemsim elementāru funkciju ar diviem argumentiem:<pre>add a b = a + b</pre></p>
                    <p>Lai aprakstītu šīs funkcijas tipu, tiek izmantots šāds pieraksts:<pre>add :: Int -> Int -> Int</pre></p>
                    <p>Šo pierakstu jālasa tā: funkcija add saņem divus argumentus ar tipu Int un atgriež rezultātu ar tipu Int.</p>
                    <p>Sākumā šitāds pieraksts liekas neloģisks, jo argumenti ir samesti kopā ar rezultātu. Ar laiku Jūs sapratīsiet, kāpēc pieraksts ir tieši šāds, pateicoties procesam, kas saucās karings.</p>
                    <p>Pierakstīt funkcijas tipu lielākoties nav obligāti. Šāda vajadzība parādās diezgan reti. Bet tos ir jāprot lasīt, lai varētu viegli orientēties gatavajās funkcijās.</p>
                </div>
                <div class="slide">
                    <h2>Primitīvie tipi</h2>
                    <p>Var nošķirt 5 primitīvus tipus: Int, Integer, Float, Char, Bool.</p>
                    <p>Int tiek ierobežots ar datora arhitektūras "vārda" izmēru.</p>
                    <p>Integer ir neierobežoti veselie skaitļi. Float ir skaitļi ar peldošo punktu.</p>
                    <p>Char ir simbolu tips: viens simbols ir ierobežots ar parastajām pēdiņām - 'a'. </p>
                    <p>Bool ir būla mainīgie, kas var būt True vai False.</p>
                </div>
                <div class="slide">
                    <h2>Saraksti</h2>
                    <p>Tāpat, kā citās valodās, Haskell ļauj izveidot sarakstu ar noteikta tipa elementiem. Piemēram, [1, 2, 3, 4, 5] ir saraksts ar skaitļiem.</p>
                    <p>Saraksta elementiem ir jābūt viena tipa. Izveidojot sarakstu ar jauktiem tipiem, piemēram, [1, 'a'] izsauks kompilācijas kļūdu.</p>
                    <p>Simbolu saraksts atzīmējas kā saraksts [Char] vai ar tā sinonīmu, String. Lai izveidotu String tipa mainīgo, vajag izmantot dubultpēdiņas - "abcd". Tas pieraksts ir <u id="sugar" class="def">sintaktiskais atvieglojums</u> simbolu sarakstam - ['a', 'b', 'c', 'd'].</p>
                    <p>Atšķirībā no tādām valodām kā PHP vai JavaScript, Haskell piespiež programmētāju izmantot vajadzīgā veida pēdiņas. Tas nozīmē, ka konstrukcija 'abcd' izsauks kompilācijas kļūdu - Haskell gaida, ka ar '' ir definēts Char tipa mainīgais, nevis [Char]. Savukārt konstrukcija "a" neizsauks kļūdu, bet izveidos [Char] tipa mainīgo.</p>
                </div>
                <div class="slide">
                    <h2>Pāri</h2>
                    <p>Pāris ir konstrukcija, kas var būt pazīstama Python programmētājiem. Pāris satur divus elementus, kuriem var būt dažādi tipi, piemēram, (1, "abcd").</p>
                    <p>Pāris var sastāvēt no vairākiem elementiem, piemēram, (1, "Jānis Bērziņš", 1987). Bet funkcijas, kas ir domātas pāriem no diviem elementiem, nestrādās ar pāriem no vairākiem elementiem, piemēram:</p>
                    <pre>foo (a, b) = a

main = print (foo (1, "Jānis Bērziņš", 1987))</pre>
                    <p>Šis kods izsauks kompilācijas kļūdu.</p>
                    <p>Visbiežāk tiek izmantots pāris no 2 elementiem, un tam ir definētas funkcijas, kas ir pieejamas ar bāzes paku Prelude - fst un snd, kuras atgriež attiecīgi pirmo un otro pāra elementu.</p>
                </div>
                <div class="slide">
                    <h2>Argumenti</h2>
                    <p>Haskell valodā ir dažas iespējas, kuras var atvieglot funkciju veidošanu. Viena no tām ir tā saucamais pattern mattching. Izveidosim <u id="recursive" class="def">rekursīvu</u> <u id="factorial" class="def">faktoriāļa</u> funkciju:<pre>fact n = if n == 0 then 1 else n * fact (n - 1)</pre></p>
                    <p>Mēs varam padarīt to nedaudz lasāmāku ar guard simboliem:</p>
                    <pre>fact n
    | n == 0    = 1
    | otherwise = n * fact (n - 1)</pre>
                    <p>vai definējot funkciju specifiskai vērtībai:
                    <pre>fact 0 = 1
fact n = n * fact (n - 1)</pre>
                </div>
                <div class="slide">
                    <h2>Funkcijas ar sarakstiem</h2>
                    <p>Haskell atbalsta pattern matching iespējas, kas ir domātas sarakstiem. Piemēram, var definēt funkcijas versiju tukšam sarakstam vai izdalot saraksta elementus.</p>
                    <p>Izveidosim funkciju, kas pārveido vārda pirmo burtu augšējā reģistrā (atceramies, ka rinda ir simbolu saraksts):</p>
                    <pre>import Data.Char

cap [] = ""
cap (x:xs) = toUpper x : xs

main = print (cap "hello")</pre>
                    <p>Pirmā rinda pievieno bibliotēku Data.Char, kas satur funkciju toUpper. Nākamā rinda definē funkcijas cap versiju gadījumam, ja tiek padots tukšs saraksts - tajā gadījumā mēs atgriežam tukšu sarakstu.</p>
                    <p>Nākamajā rindā mēs ar pattern matching pierakstu (x:xs) atdalam pirmo elementu x no pārējas listes xs. Mēs ieceļam to simbolu augšējā reģistrā ar toUpper un tad pievienojam pie pārējā saraksta ar : operātoru.</p>
                </div>
                <div class="slide">
                    <h2>Citas pattern matching iespējas</h2>
                    <pre>foo n@123 = n
foo _ = 456</pre>
                    <p>Pirmā rinda definē funkciju foo gadījumam, ja arguments n ir vienāds ar 123. Otrā rindā pattern "_" tiek izmantots, lai pilnībā ignorētu argumentu.</p>
                    <pre>first  (a, b) = a
second (a, b) = b</pre>
                    <p>Atdalām pāra elementus.</p>
                </div>
                <div class="slide">
                    <h2>Map & Fold</h2>
                    <p>Sarakstiem ir ļoti nopietna loma Haskell valodā. Ir vērts izcelt divas galvenās funkcijas darbam ar sarakstiem: map un fold. Citās valodās fold tiek saukts par reduce, bet fold nosaukums ir nedaudz loģiskāks, jo rezultātā liste tiek "salikta" vienā vērtībā.</p>
                    <p>Funkcija map pieņem divus argumentus - funkciju un sarakstu. Map funkcija iziet cauri sarakstam un izpilda padoto funkciju ar katru saraksta elementu. Piemēram, mums ir saraksts un mums vajag atrast kvadrātu no katra elementa:</p>
                    <pre>sqr n = n ^ 2

main = print (map sqr [1,2,3,4,5])</pre>
                    <p>Rezultātā redzēsim [1, 4, 9, 16, 25].</p>
                    <p>Funkcijas map tips ir map :: (a -> b) -> [a] -> [b]. Šo var izlasīt: pirmais arguments ir tipa a -> b funkcija, tas ir funkcija, kas pieņem argumentu ar tipu a un atgriež rezultātu ar tipu b. Otrais ir saraksts ar tipa a vērtībām. Rezultāts ir saraksts ar tipa b vērtībam. a un b šajā pierakstā ir simboliski aizvietojumi, kas demonstrē, ka tur var būt jebkādi tipi.</p>
                </div>
                <div class="slide">
                    <h2>Map & Fold</h2>
                    <p>Funkcija fold ir nedaudz sarežģītāka. Tā uzkrāj rezultātu vienā mainīgajā, ko sauc par akumulatoru. Tā izmanto funkciju ar diviem mainīgajiem. Kā pirmā tai tiek padota akumulatora vērtība, otrais arguments tiek paņemts no saraksta. Rezultāts atjauno akumulatora vērtību.</p>
                    <p>Piemēram, mēs izmantojam akumulatora vērtību 1, sarakstu [2, 3, 4] un funkciju foo a b = 2 * a + b. Izmantosim fold versiju, kas sāk no saraksta kreisās puses - foldl:</p>
                    <pre>foo a b = 2 * a + b

main = print (foldl foo 1 [2,3,4])</pre>
                    <p>Ja attēlo, ko dara foldl, sanāk 4 soļi:
                        <ol>
                            <li>1. Funkcija foo saņem argumentus 1 un 2, rezultāts 1 * 2 + 2 = 4 tiek ierakstīts akumulatorā, sarakstā paliek [3, 4]</li>
                            <li>2. Funkcija foo saņem argumentus 4 un 3, rezultāts 4 * 2 + 3 = 11 tiek ierakstīts akumulatorā, sarakstā paliek [4]</li>
                            <li>3. Funkcija foo saņem argumentus 11 un 4, rezultāts 11 * 2 + 4 = 26 tiek ierakstīts akumulatorā, saraksts ir tukšs</li>
                            <li>4. Šis solis notiek, kad saraksts kļuvis tukšs. Šajā gadījumā tiek vienkārši atgriezta akumulatora vērtība, un rekursija apstājas.</li>
                        </ol>
                    </p>
                </div>
                <div class="slide">
                    <h2>Map & Fold</h2>
                    <p>Patreiz jums ir jābūt pietiekami daudz zināšanām, lai paši saprastu, kā darbojas funkcijas map un foldl, izlasot šo funkciju kodu. Pamēģiniet to izdarīt, pirms turpināsiet lasīt:</p>
                    <pre>map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs</pre>
                    <pre>foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f z []     = z
foldl f z (x:xs) = foldl f (f z x) xs</pre>
                </div>
                <div class="slide">
                    <h2>Noderīgas funkcijas</h2>
                    <p>: - pievienot elementu sarakstam. 1 : [2, 3] atgriezīs [1, 2, 3]</p>
                    <p>++ - salīmēt divus sarakstus. [1, 2] ++ [3, 4, 5] atgriezīs [1, 2, 3, 4, 5]</p>
                    <p>fst, snd - atgiež pāra no 2 elementiem pirmo un otro elementu respektīvi.</p>
                    <p>head, last - atgriež saraksta pirmo vai pēdējo elementu respektīvi. head [1, 2, 3] atgriezīs 1</p>
                    <p>init, tail - atgriež sarakstu bez pēdēja vai pirma elementa respektīvi. tail [1, 2, 3] atgriezīs [2, 3]</p>
                    <p>filter - filtrēt sarakstu, izmantojot funkciju. filter odd [1..10] atgriezīs [1, 3, 5, 7, 9]</p>
                    <p>all - pārbaudīt, vai visi elementi atbilst noteikumam. all odd [1, 3, 4, 5, 7] atgriezīs False</p>
                    <p>any - pārbaudīt, vai kaut viens elements atbilst noteikumam. any odd [2, 4 .. 10] atgriezīs False</p>
                    <p>elem - pārbaidīt, vai elements ir sarakstā. elem 3 [1 .. 10] atgriezīs True</p>
                    <p>!! - atgriezt sarakstes n-to elementu. [1 .. 10] !! 5 atgriezīs 4 (1 ir nultais elements)</p>
                </div>
                <div class="slide">
                    <h2>Prefix un infix pieraksti</h2>
                    <p>Visbiežāk ir sastopams prefix pieraksts funkcijām - kad funkcijas nosaukums ir pirms argumentiem. Funkcijām ar 2 argumentiem pastāv iespēja izmantot infix pierakstu. Lai izmantotu infix pierakstu funkcijai, kuras nosaukums sastāv no burtiem, mēs varam izmantot backquote simbolus. Izveidosim funkciju, kas aprēķina procentus no skaitļa:</p>
                    <pre>percent a b = a / b * 100
                    
main = do
    print (percent 20 160)
    print (20 `percent` 160)</pre>
                    <p>Savukārt, ja funkcijas nosaukums sastāv no simboliem (operatori), tad backquotes izmantot ar infix pierakstu nevajag, bet ar prefix pierakstu vajag izmantot iekavas:</p>
                    <pre>a % b = a / b * 100
                   
main = do
    print (20 % 160)
    print ((%) 20 160)</pre>
                </div>
                <div class="slide">
                    <h2>Anonimas funkcijas</h2>
                    <p>Anonimas vai lambda funkcijas ir funkcijas, kurām nav nosaukums. Tās bieži tiek izmantotas augstākās kārtas funkcijas (jeb funkcijās, kuras izmanto citas funkcijas kā argumentus)</p>
                    <p>Haskell valoda uzmanto šādu pierakstu lambda funkcijām: (a -> do_something a). Piemēram, funkcija, kas ieceļ skaitli kvadrātā, izskatīsies šādi: (a -> a^2)</p>
                    <p>Izmantot lambda funkcijas var šādi:</p>
                    <pre>map (a -> a^2) [1, 2, 3, 4, 5]</pre>
                    <p>Līdzīgi, kā mēs vienkāršojām cube funkciju, lambda funkcijas arī var vienkaršot (process saucās eta reduction):</p>
                    <pre>map (^2) [1, 2, 3, 4, 5]</pre>
                </div>
                <div class="slide">
                    <h2>Karings</h2>
                    <p>Karings ir process, kas pārveido funkciju ar vairākiem argumentiem par virkni funkciju, katra no tām ar vienu argumentu. Matemātiskās funkcijas var izmantot tikai vienu argumentu, un tīri funkcionālās valodās funkcijām ir jāatbilst šim noteikumam. Bet, lai atvieglotu programmētāja darbu, tika izveidots mehanisms, kas ļauj veidot funkcijas ar vairākiem argumentiem, nepārkāpjot tīri funkcionālo principu.</p>
                    <p>Piemēram, mēs gribam uztaisīt funkciju foo a b = a + b. Pirmkārt, pierakstīsim šo funkciju prefix pierakstā - foo a b = (+) a b. Tālāk, izdomāsim funkciju (x -> x + a). Mēs redzam, ka šo funkciju mēs varam ievietot mūsu galvēnā funkcijā: foo a b = (x -> x + a) b. Un līdzīgi kā iepriekš, ar eta reduction vienkāršosim to funkciju: foo a b = (+a) b</p>
                    <p>Šis process saucās karings (currying, no matemātiķa Haskell Curry uzvārda). To dara Haskell kompilātors katru reizi, kad tiek izveidota funkcija ar vairākiem parametriem.</p>
                    <p>Tieši tāpēc Haskell izmanto tādus tipu pierakstus - tie demonstrē, kā funkcijas reducējas līdz vienam mainīgajam.</p>
                </div>
            </div>
        </div>
        <div class="tryit">
            Try-it editor, coming soon...
        </div>
    </div>
    <div id="tooltip">
        <div id="tooltip_functional" class="tooltip">Funkcionālās valodas ir valodas, kas izpilda programmu līdzīgi matemātiskai funkcijai, neizmantojot stāvokli un mainīgus datus.</div>
        <div id="tooltip_imperative" class="tooltip">Imperatīvās valodas ir valodas, kas veido programmu kā sarakstu ar soļiem, un pēc katra soļa mainās programmas stāvoklis.</div>
        <div id="tooltip_compiler" class="tooltip">Kompilators ir programma, kas pārveido kodu, uzrakstītu programmēšanas valodā, par kodu, kuru var izpildīt dators.</div>
        <div id="tooltip_pure" class="tooltip">Tīri funkcionāla valoda ir valoda, kurā funkcijas nesatur blakus efektus. Tas nozīmē, ka funkcijas saņem argumentus, apstradā un atgriež rezultātu, un nedara neko citu - ne datu attēlošanu, ne saglabāšanu failos vai jebkādu citu darbību.</div>
        <div id="tooltip_oop" class="tooltip">Object Oriented valodas ir valodas, kas izmanto objektus kā valodas pamatelementus. Objekti sastāv no elementiem un metodēm.</div>
        <div id="tooltip_boilerplate" class="tooltip">Boilerplate ir daļa no koda, kuru gandrīz vienmēr vai vienmēr ir jāliek programmā.</div>
        <div id="tooltip_type" class="tooltip">Mainīgo vai argumentu tips programmēšanā nosaka, kādi dati var būt izmantoti ar šo mainīgo un kādas operācijas ir atļautas. Piemēram, skaitļu tipiem ir atļautas aritmētiskās operācijas.</div>
        <div id="tooltip_recursive" class="tooltip">Rekursīva funkcija ir funkcija, kas izsauc pati sevi.</div>
        <div id="tooltip_sugar" class="tooltip">Sintaktiskais atvieglojums jeb sintaktiskais cukurs ir kāda koda aizvietojums, kas padara to lasāmāku vai ērtāk izmantojamu.</div>
        <div id="tooltip_factorial" class="tooltip">Faktoriālis ir funkcija ar argumentu n, kuras rezultāts ir visu skaitļu no 1 līdz n reizinājums, piemēram, fact(5) = 1*2*3*4*5 = 120. Tiek pieņemta faktoriāļa definīcija: ja n ir 0, tad faktoriālis ir 1, citos gadījumos faktoriālis ir n reiz faktoriālis no n-1.</div>
    </div>
    <script type="text/javascript" src="index.js"></script>
</body>
</html>
