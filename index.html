<html>
<head>
    <meta charset="utf-8">
    <title>haskell.lv</title>
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="/index.css">
</head>
<body>
    <div class="header">
        <img src="logo.png" id="logo" />
        <div class="nav">
           <a href="/">Apmācība</a>
           <a href="https://www.haskell.org/downloads" target="_blank">Lejupielādēt</a>
           <a href="/irc.html">IRC</a>
           <a href="/news.html">Ziņas</a>
           <a href="/links.html">Saites uz citiem resursiem</a>
        </div>
    </div>
    <h1>Apmācība</h1>
    <div class="content">
        <div class="tutorial">
            <div id="trigger_summary">></div>
            <div id="summary">
                <ul>
                    <li><a href="/#1">Ievads (1-3)</a></li>
                    <li><a href="/#4">Koda piemēri (4-6)</a></li>
                    <li><a href="/#7">Kā iesākt (7-9)</a></li>
                    <li><a href="/#11">Tipi (11-15)</a></li>
                    <li><a href="/#16">Argumenti (16-18)</a></li>
                    <li><a href="/#19">Noderīgas funkcijas darbam ar sarakstiem (19-20)</a></li>
                    <li><a href="/#21">Map & Fold (21-24)</a></li>
                    <li><a href="/#25">Prefix un infix pieraksti (25)</a></li>
                    <li><a href="/#26">Anonīmās funkcijas (26-27)</a></li>
                    <li><a href="/#28">Karings, kompizīcijas un aplikācijas (28-32)</a></li>
                    <li><a href="/#33">Lazy (33-37)</a></li>
                    <li><a href="/#38">List comprehension (38)</a></li>
                    <li><a href="/#39">Izteikumu tipi (39-42)</a></li>
                    <li><a href="/#43">Tipu klases (43-47)</a></li>
                    <li><a href="/#48">Tipu konstruktori (48-52)</a></li>
                    <li><a href="/#53">Funktori (53-55)</a></li>
                    <li><a href="/#56">Monādes (56-60)</a></li>
                    <li><a href="/#61">IO monāde (61-64)</a></li>
                    <li><a href="/#65">Monādiskās funkcijas (65-70)</a></li>
                </ul>
            </div>
            <div id="prev" class="slide-button slide-nav">&larr;</div>
            <div id="slidenum" class="slide-nav"></div>
            <div id="next" class="slide-button slide-nav">&rarr;</div>
            <div class="wrapper">
                <div class="slide">
                    <h2>Ievads</h2>
                    <p class="intro">Šī apmācība ir domāta cilvēkiem, kas vēlas apgūt Haskell programmēšanas valodu. Apmācība, pirmkārt, ir domāta tiem, kas jau māk programmēt citās valodās. Bet, ja Jums nav pieredzes programmēšanā vai kaut kāds termins nav saprotams, tad Jūs varat uzbraukt ar peli uz pasvītrotajiem terminiem un izlasīt definīciju. Savukārt, atbildes uzdevumiem tiks parādītas, uzklikšķinot uz tām.</p>
                    <h2>Kas ir Haskell</h2>
                    <p>Haskell ir <u id="functional" class="def">funkcionāla</u> valoda, kurai piemīt vairākas īpašības, kas izceļ to citu programmēšanas valodu starpā. Tā ir <u id="pure" class="def">tīri funkcionāla</u>, bet tajā paša laikā ļauj viegli rakstīt <u id="imperative" class="def">imperatīvu</u> kodu. Tai ir ļoti attīstīta <u id="type" class="def">tipu</u> sistēma, kas ļauj izvairīties no daudzām kļūdām. Tai ir diezgan daudz sintakses iespēju, kas ļauj rakstīt lakonisku un saprotamu kodu.</p>
                </div>
                <div class="slide">
                    <h2>Mīti par Haskell</h2>
                    <p>Haskell ir viena no populārākajām funkcionālajām valodām. Ir diezgan daudz cilvēku, kas māk rakstīt kodu ar Haskell (diemžēl, Latvijā tādu cilvēku joprojām ir maz). Bet vēl vairāk ir cilvēku, kas par Haskell ir dzirdējuši visādus mītus un turpina tos izplatīt. Šeit es apkopošu tos mītus un paskaidrošu, kāpēc tie ir tikai mīti.</p>
                    <h3>Lai apgūtu Haskell, ir vajadzīgas augstākās matemātikas zināšanas</h3>
                    <p>Haskell izmanto dažus kategoriju teorijas principus un ir mantojis terminus no tās. Bet kategoriju teoriju nav jāzina, lai varētu apgūt Haskell. Otrādi - ja cilvēks ir apgūvis Haskell, var teikt, ka viņš ir apguvis kategoriju teorijas pamatus.</p>
                    <h3>Haskell ir grūta valoda</h3>
                    <p>Haskell ir diezgan vienkārša valoda. Tajā ir ļoti maz elementu, mazāk nekā <u id="oop" class="def">OOP</u> valodās. Sākumā ir grūti pierast pie valodas lakoniskuma, pie dažu <u id="boilerplate" class="def">boilerplate</u> elementu neesamības. Bet pie tā pierod pāris dienu laikā.</p>
                </div>
                <div class="slide">
                    <h2>Mīti par Haskell</h2>
                    <h3>Ar Haskell ir grūti uzrakstīt lietojamu kodu</h3>
                    <p>Cilvēkiem, kuri nāk no OOP pasaules, ir grūti pierast pie tā, ka Haskellā nepastāv mainīgie un stāvoklis. Kad cilvēks sakrāj pieredzi un iemācās pareizi strukturēt kodu, viņš saprot, kāpēc stāvoklis ir tas, kas veicina kļūdas programmas izpildes laikā. Savukārt stāvoklis Haskell programmās ir iegūstams ar speciāliem datu tipiem.</p>
                    <h3>Haskell zināšanas ir bezjēdzīgas, jo nevar atrast darbu</h3>
                    <p>Haskell nav izplatīts Latvijā, bet mūsdienās programmētājiem attālums nav šķērslis, un par Haskell darbiem ārzemnieki ir gatavi maksāt diezgan lielu naudu. Kā arī, Haskell apgūšana maina programmētāja domāšanu un atver pavisam citādāku skatu uz programmēšanu.</p>
                </div>
                <div class="slide">
                    <h2>Daži koda piemēri</h2>
                    <pre>a = 2 + 3</pre>
                    <p>a saturēs 5.</p>
                    <br />
                    <pre>list = [1,2,3,4,5]

anotherList = [1..10]</pre>
                    <p>Tiek izveidoti 2 saraksti, viens ar skaitļiem no 1 līdz 5, otrs - no 1 līdz 10.</p>
                    <br />
                    <pre>toUpper 'a'</pre>
                    <p>Atgriež 'A'.</p>
                </div>
                <div class="slide">
                    <h2>Funkcijas</h2>
                    <p>Haskell valodas galvenais elements ir funkcijas. Funkciju definīcija arī ir īsa un lakoniska:</p>
                    <pre>cube x = x ^ 3</pre>
                    <p>Kā var redzēt, Haskell neprasa nekādu funkcijas atslēgvārdu, piemēram, function vai def. Tas tiek panākts ar to, ka funkcijas ir valodas pamatelements.</p>
                    <p>Funkcijas argumenti tiek padoti pēc funkcijas nosaukuma ar atstarpi, piemēram:</p>
                    <pre>triangleArea a h = a * h / 2</pre>
                </div>
                <div class="slide">
                    <h2>Programmas</h2>
                    <p>Haskell programmas ir ļoti lakoniskas un satur ļoti maz boilerplate:</p>
                    <pre>
cube x = x ^ 3

main = print (cube 4)</pre>
                    <p>Un pat šo programmu var padarīt īsāku. Ja mēs skatāmies uz funkciju cube, tad viss, ko tā dara - kāpina argumentu trešajā pakāpē. Mums šajā situācijā ir vienalga, kāds ir arguments, mums ir svarīgi, ko funkcija dara. Tāpēc pierakstīsim to citādāk:<p>
                    <pre>cube = (^3)

main = print (cube 4)</pre>
                    <p>Izmantojot šo pieeju, kods var sanākt ļoti tīrs un daudz lasāmāks.</p>
                </div>
                <div class="slide">
                    <h2>Kā iesākt</h2>
                    <p>Iesācējiem ir rekomendēts uzinstalēt haskell-platform, piemēram</p>
                    <pre>sudo apt-get install haskell-platform</pre>
                    <p>Tas iekļauj sevī GHC <u id="compiler" class="def">kompilātoru</u>, Cabal paku menedžeri un dažas izplatītas pakas.</p>
                    <p>Programmētāji ar lielāku pieredzi var uzinstalēt tikai ghc.</p>
                    <p>Lai instalētu vajadzīgās pakas, var izmantot komandu <pre>cabal install package_name</pre></p>
                    <p>Ir noderīgi apgūt arī interaktīvo interpretatoru, ghci.</p>
                </div>
                <div class="slide">
                    <h2>Pirmā programma</h2>
                    <p>Izveidojiet failu hello.hs un ierakstiet šo kodu:</p>
                    <pre>main = print "Hello world!"</pre>
                    <p>Sakompilējiet to ar</p>
                    <pre>ghc hello.hs</pre>
                    <p>Jūs redzēsiet paziņojumus:</p>
                    <pre>
[1 of 1] Compiling Main             ( hello.hs, hello.o )
Linking hello ...</pre>
                    <p>Sakompilēto programmu var palaist ar <pre>./hello</pre></p>
                </div>
                <div class="slide">
                    <h2>Darbs ar interpretatoru</h2>
                    <p>Kopā ar GHC instalāciju nāk arī interaktīvais interpretators GHCi, kurš ļauj izpildīt Haskell izteiksmes un redzēt rezultātu. Tāpat GHCi ļauj analizēt un labot kļūdas gataviem moduļiem vai programmām.</p>
                    <p>Lai palaistu interpretatoru, vajag izpildīt komandu "ghci" komandrindā. Jūs redzēsiet rindu "Prelude> ", tajā momentā ghci ir gatavs darbam.</p>
                    <p>ghci ļauj izpildīt jebkuru Haskell kodu. Piemēram, ierakstot map (^2) [1..5], Jūs uzreiz redzēsiet rezultātu.</p>
                    <p>Haskell programmētāji izmanto ghci diezgan bieži, tāpēc ir vērts to konfigurēt. Lai to izdarītu ir jāizveido fails $HOME/.ghci. Kā piemērs, var nomainīt prefiksu:</p>
                    <pre>:set prompt "λ> "</pre>
                    <p>Palaižot ghci nākamreiz, jūs redzēsiet "λ> " "Prelude> " vietā.</p>
                </div>
                <div class="slide">
                    <h2>Starpība starp kompilatoru un interpretatoru</h2>
                    <p>Viss Haskell kods, kas tiek padots interpretatoram, tiek uztvērts kā izteikums. Ja Jūs gribēsiet GHCi definēt kādu funkciju, piemēram</p>
                    <pre>foo a b = a + b</pre>
                    <p>Jūs redzēsiet kļūdu. Tas skaidrojas ar to, ka visas Haskell funkciju definīcijas ir deklaratīvas, tie nav izteikumi. Atslēgvārds let un konstrukcija let .. in .. ļauj veidot definīcijas izteikumos. Piemēri:</p>
                    <pre>λ> let foo a b = a + b
λ> foo 2 3
5</pre>
                    <pre>λ> let foo a b = a + b in foo 2 3
5</pre>
                    <p>Atšķirība starp abiem piemēriem ir tajā, ka pirmais nodefinē funkciju foo, kas eksistēs, kamēr GHCi ir atvērts. Savukārt otrajā foo eksistēs tikai izteikuma robežās - ja mēģināt pēc tam izsaukt foo 2 3, jūs redzēsiet kļūdu (ja pirms tam neesa nodefinējuši foo ar let).</p>
                </div>
                <div class="slide">
                    <h2>Tipi</h2>
                    <p>Haskell tipu sistēma ir ļoti advancēta un dara ļoti daudz darba, lai nodrošinātu programmas stabilitāti. Bet sākumā ir nepieciešams saprast, kā Haskell funkcijām tiek aprakstīti tipi. Paņemsim elementāru funkciju ar diviem argumentiem:<pre>add a b = a + b</pre></p>
                    <p>Lai aprakstītu šīs funkcijas tipu, tiek izmantots šāds pieraksts:<pre>add :: Int -> Int -> Int</pre></p>
                    <p>Šo pierakstu jālasa tā: funkcija add saņem divus argumentus ar tipu Int un atgriež rezultātu ar tipu Int.</p>
                    <p>Sākumā šāds pieraksts liekas neloģisks, jo argumenti ir samesti kopā ar rezultātu. Ar laiku Jūs sapratīsiet, kāpēc pieraksts ir tieši šāds, pateicoties procesam, kas saucās karings.</p>
                    <p>Pierakstīt funkcijas tipu lielākoties nav obligāti. Šāda vajadzība parādās diezgan reti. Bet tos ir jāprot lasīt, lai varētu viegli orientēties gatavajās funkcijās.</p>
                </div>
                <div class="slide">
                    <h2>Primitīvie tipi</h2>
                    <p>Var nošķirt 5 primitīvus tipus: Int, Integer, Float, Char, Bool.</p>
                    <p>Int ir veselie skaitļi, kuru diapazons tiek ierobežots ar datora arhitektūru. Piemēram, 32 bitu arhitektūrā Int skaitļi ir no -2147483648 līdz 2147483647.</p>
                    <p>Integer ir neierobežoti veselie skaitļi.</p>
                    <p>Float ir skaitļi ar peldošo punktu, jeb reālie skaitļi, piemēram 1.23.</p>
                    <p>Char ir simbolu tips: viens simbols ir ierobežots ar parastajām pēdiņām - 'a'.</p>
                    <p>Bool ir būla mainīgie, kas var būt True vai False.</p>
                </div>
                <div class="slide">
                    <h2>Saraksti</h2>
                    <p>Tāpat, kā citās valodās, Haskell ļauj izveidot sarakstu ar noteikta tipa elementiem. Piemēram, [1, 2, 3, 4, 5] ir saraksts ar skaitļiem.</p>
                    <p>Saraksta elementiem ir jābūt viena tipa. Izveidojot sarakstu ar jauktiem tipiem, piemēram, [1, 'a'] izsauks kompilācijas kļūdu.</p>
                    <p>Simbolu saraksts atzīmējas kā saraksts [Char] vai ar tā sinonīmu, String. Lai izveidotu String tipa mainīgo, vajag izmantot dubultpēdiņas - "abcd". Tas pieraksts ir <u id="sugar" class="def">sintaktiskais atvieglojums</u> simbolu sarakstam - ['a', 'b', 'c', 'd'].</p>
                    <p>Atšķirībā no tādām valodām kā PHP vai JavaScript, Haskell piespiež programmētāju izmantot vajadzīgā veida pēdiņas. Tas nozīmē, ka konstrukcija 'abcd' izsauks kompilācijas kļūdu - Haskell gaida, ka ar '' ir definēts Char tipa mainīgais, nevis [Char]. Savukārt konstrukcija "a" neizsauks kļūdu, bet izveidos [Char] tipa mainīgo.</p>
                </div>
                <div class="slide">
                    <h2>Pāri</h2>
                    <p>Pāris ir konstrukcija, kas var būt pazīstama Python programmētājiem. Pāris satur divus elementus, kuriem var būt dažādi tipi, piemēram, (1, "abcd").</p>
                    <p>Pāris var sastāvēt no vairākiem elementiem, piemēram, (1, "Jānis Bērziņš", 1987). Bet funkcijas, kas ir domātas pāriem no diviem elementiem, nestrādās ar pāriem no vairākiem elementiem, piemēram:</p>
                    <pre>foo (a, b) = a

main = print (foo (1, "Jānis Bērziņš", 1987))</pre>
                    <p>Šis kods izsauks kompilācijas kļūdu.</p>
                    <p>Visbiežāk tiek izmantots pāris no 2 elementiem, un tam ir definētas funkcijas, kas ir pieejamas ar bāzes paku Prelude - fst un snd, kuras atgriež attiecīgi pirmo un otro pāra elementu.</p>
                </div>
                <div class="slide">
                    <h2>Uzdevumi</h2>
                    <p>Šeit būs nelieli uzdevumi, kuru atbildes ir paslēptas zemāk (uzklikšķiniet, lai to redzētu).</p>
                    <p>Izdomājiet galvā tipu funkcijai foo a b = toUpper a : b.</p>
                    <pre class="spoiler">Char -> [Char] -> [Char]</pre>
                    <p>Uzrkastiet funkciju, kas maina vietām pāra elementus.</p>
                    <pre class="spoiler">foo pair = (snd pair, fst pair)
vai
foo (a, b) = (b, a)</pre>
                    <p>Uzrakstiet funkciju, kas saņem trīs argumentus un saliek tos sarakstā, pretējā secībā.</p>
                    <pre class="spoiler">foo a b c = [c, b, a]</pre>
                </div>
                <div class="slide">
                    <h2>Argumenti</h2>
                    <p>Haskell valodā ir dažas iespējas, kuras var atvieglot funkciju veidošanu. Viena no tām ir tā saucamais pattern mattching. Izveidosim <u id="recursive" class="def">rekursīvu</u> <u id="factorial" class="def">faktoriāļa</u> funkciju:<pre>fact n = if n == 0
            then 1
            else n * fact (n - 1)</pre></p>
                    <p>Mēs varam padarīt to nedaudz lasāmāku ar guard simboliem:</p>
                    <pre>fact n
    | n == 0    = 1
    | otherwise = n * fact (n - 1)</pre>
                    <p>vai definējot funkciju specifiskai vērtībai:
                    <pre>fact 0 = 1
fact n = n * fact (n - 1)</pre>
                </div>
                <div class="slide">
                    <h2>Funkcijas ar sarakstiem</h2>
                    <p>Haskell atbalsta pattern matching iespējas, kas ir domātas sarakstiem. Piemēram, var definēt funkcijas versiju tukšam sarakstam vai izdalot saraksta elementus.</p>
                    <p>Izveidosim funkciju, kas pārveido vārda pirmo burtu augšējā reģistrā (atceramies, ka rinda ir simbolu saraksts):</p>
                    <pre>import Data.Char

cap [] = ""
cap (x:xs) = toUpper x : xs

main = print (cap "hello")</pre>
                    <p>Pirmā rinda pievieno bibliotēku Data.Char, kas satur funkciju toUpper. Nākamā rinda definē funkcijas cap versiju gadījumam, ja tiek padots tukšs saraksts - tajā gadījumā mēs atgriežam tukšu sarakstu.</p>
                    <p>Nākamajā rindā mēs ar pattern matching pierakstu (x:xs) atdalam pirmo elementu x no pārējas listes xs. Mēs ieceļam to simbolu augšējā reģistrā ar toUpper un tad pievienojam pie pārējā saraksta ar : operatoru.</p>
                </div>
                <div class="slide">
                    <h2>Citas pattern matching iespējas</h2>
                    <pre>foo n@123 = n
foo _ = 456

main = do
    print (foo 123)
    print (foo 111)</pre>
                    <p>Pirmā rinda definē funkciju foo gadījumam, ja arguments n ir vienāds ar 123. Otrā rindā pattern "_" tiek izmantots, lai pilnībā ignorētu argumentu.</p>
                    <pre>first  (a, b) = a
second (a, b) = b</pre>
                    <p>Atdalām pāra elementus.</p>
                </div>
                <div class="slide">
                    <h2>Noderīgas funkcijas darbam ar sarakstiem</h2>
                    <p>: - pievienot elementu sarakstam. 1 : [2, 3] atgriezīs [1, 2, 3]</p>
                    <p>++ - salīmēt divus sarakstus. [1, 2] ++ [3, 4, 5] atgriezīs [1, 2, 3, 4, 5]</p>
                    <p>fst, snd - atgiež 2 elementu pāra pirmo un otro elementu respektīvi.</p>
                    <p>head, last - atgriež saraksta pirmo vai pēdējo elementu respektīvi. head [1, 2, 3] atgriezīs 1</p>
                    <p>init, tail - atgriež sarakstu bez pēdējā vai pirmā elementa respektīvi. tail [1, 2, 3] atgriezīs [2, 3]</p>
                    <p>filter - filtrēt sarakstu, izmantojot funkciju. filter odd [1..10] atgriezīs [1, 3, 5, 7, 9]</p>
                    <p>all - pārbaudīt, vai visi elementi atbilst nosacījumam. all odd [1, 3, 4, 5, 7] atgriezīs False</p>
                    <p>any - pārbaudīt, vai kaut viens elements atbilst nosacījumam. any odd [2, 4 .. 10] atgriezīs False</p>
                    <p>elem - pārbaidīt, vai elements ir sarakstā. elem 3 [1 .. 10] atgriezīs True</p>
                    <p>!! - atgriezt sarakstes n-to elementu. ['a'..'z'] !! 3 atgriezīs 'd' (elementus sāk skaitīt no 0)</p>
                </div>
                <div class="slide">
                    <h2>Uzdevumi</h2>
                    <p>Uzrakstiet rekursīvo funkciju, kas aprēķina n-to Fibonacci skaitli.</p>
                    <pre class="spoiler">fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)</pre>
                    <p>Uzrakstiet rekursīvo funkciju, kas apgriež rindu otrādi.</p>
                    <pre class="spoiler">foo [] = []
foo line = last line : foo (init line)</pre>
                </div>
                <div class="slide">
                    <h2>Map & Fold</h2>
                    <p>Sarakstiem ir ļoti nopietna loma Haskell valodā. Ir vērts izcelt divas galvenās funkcijas darbam ar sarakstiem: map un fold. Citās valodās fold tiek saukts par reduce, bet fold nosaukums ir nedaudz loģiskāks, jo rezultātā liste tiek "salikta" vienā vērtībā.</p>
                    <p>Funkcija map pieņem divus argumentus - funkciju un sarakstu. Map funkcija iziet cauri sarakstam un izpilda padoto funkciju ar katru saraksta elementu. Piemēram, mums ir saraksts un mums vajag atrast kvadrātu no katra elementa:</p>
                    <pre>sqr n = n ^ 2

main = print (map sqr [1,2,3,4,5])</pre>
                    <p>Rezultātā redzēsim [1, 4, 9, 16, 25].</p>
                    <p>Funkcijas map tips ir map :: (a -> b) -> [a] -> [b]. Šo var izlasīt: pirmais arguments ir tipa a -> b funkcija, tas ir funkcija, kas pieņem argumentu ar tipu a un atgriež rezultātu ar tipu b. Otrais ir saraksts ar tipa a vērtībām. Rezultāts ir saraksts ar tipa b vērtībam. a un b šajā pierakstā ir simboliski aizvietojumi, kas demonstrē, ka tur var būt jebkādi tipi.</p>
                </div>
                <div class="slide">
                    <h2>Map & Fold</h2>
                    <p>Funkcija fold ir nedaudz sarežģītāka. Tā uzkrāj rezultātu vienā mainīgajā, ko sauc par akumulatoru. Tā izmanto funkciju ar diviem mainīgajiem. Kā pirmā tai tiek padota akumulatora vērtība, otrais arguments tiek paņemts no saraksta. Rezultāts atjauno akumulatora vērtību.</p>
                    <p>Piemēram, mēs izmantojam akumulatora vērtību 1, sarakstu [2, 3, 4] un funkciju foo a b = 2 * a + b. Izmantosim fold versiju, kas sāk no saraksta kreisās puses - foldl:</p>
                    <pre>foo a b = 2 * a + b

main = print (foldl foo 1 [2,3,4])</pre>
                    <p>Ja attēlo, ko dara foldl, sanāk 4 soļi:
                        <ol>
                            <li>1. Funkcija foo saņem argumentus 1 un 2, rezultāts 1 * 2 + 2 = 4 tiek ierakstīts akumulatorā, sarakstā paliek [3, 4]</li>
                            <li>2. Funkcija foo saņem argumentus 4 un 3, rezultāts 4 * 2 + 3 = 11 tiek ierakstīts akumulatorā, sarakstā paliek [4]</li>
                            <li>3. Funkcija foo saņem argumentus 11 un 4, rezultāts 11 * 2 + 4 = 26 tiek ierakstīts akumulatorā, saraksts ir tukšs</li>
                            <li>4. Šis solis notiek, kad saraksts kļuvis tukšs. Šajā gadījumā tiek vienkārši atgriezta akumulatora vērtība, un rekursija apstājas.</li>
                        </ol>
                    </p>
                </div>
                <div class="slide">
                    <h2>Map & Fold</h2>
                    <p>Patreiz jums ir jābūt pietiekami daudz zināšanām, lai paši saprastu, kā darbojas funkcijas map un foldl, izlasot šo funkciju kodu. Pamēģiniet to izdarīt, pirms turpināsiet lasīt:</p>
                    <pre>map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs</pre>
                    <pre>foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f z []     = z
foldl f z (x:xs) = foldl f (f z x) xs</pre>
                </div>
                <div class="slide">
                    <h2>Uzdevumi</h2>
                    <p>Uzrakstiet funkciju, kas izmanto map un pārverš rindu uz augšējo reģistru.</p>
                    <pre class="spoiler">foo line = map toUpper line</pre>
                    <p>Uzrakstiet funkciju, kas izmanto foldl un apgriež rindu otrādi.</p>
                    <pre class="spoiler">
foo acc char = char : acc
bar line = foldl foo "" line</pre>
                </div>
                <div class="slide">
                    <h2>Prefix un infix pieraksti</h2>
                    <p>Visbiežāk ir sastopams prefix pieraksts funkcijām - kad funkcijas nosaukums ir pirms argumentiem. Funkcijām ar 2 argumentiem pastāv iespēja izmantot infix pierakstu. Lai izmantotu infix pierakstu funkcijai, kuras nosaukums sastāv no burtiem, mēs varam izmantot backquote simbolus. Izveidosim funkciju, kas aprēķina procentus no skaitļa:</p>
                    <pre>percent a b = a / b * 100

main = do
    print (percent 20 160)
    print (20 `percent` 160)</pre>
                    <p>Savukārt, ja funkcijas nosaukums sastāv no simboliem (operatori), tad backquotes izmantot ar infix pierakstu nevajag, bet ar prefix pierakstu vajag izmantot iekavas:</p>
                    <pre>a % b = a / b * 100

main = do
    print (20 % 160)
    print ((%) 20 160)</pre>
                </div>
                <div class="slide">
                    <h2>Anonīmās funkcijas</h2>
                    <p>Anonīmās vai lambda funkcijas ir funkcijas, kurām nav nosaukuma. Tās bieži tiek izmantotas augstākas kārtas funkcijās (funkcijās, kuras izmanto citas funkcijas kā argumentus). Haskell valoda izmanto šādu pierakstu lambda funkcijām: (\a -> doSomething a). Simbols "\" pirms argumenta simbolizē grieķu simbolu lambda. Pati lambda funkciju sintakse ir mantota no lambda calculus.</p>
                    <p>Piemēram, funkcija, kas kāpina skaitli kvadrātā, izskatīsies šādi: (\a -> a^2)</p>
                    <p>Šis piemērs parāda, kā izmantot lambda funkcijas ar augstākās pakāpes funkciju map:</p>
                    <pre>map (\a -> a^2) [1, 2, 3, 4, 5]</pre>
                    <p>Līdzīgi kā mēs vienkāršojām cube funkciju, lambda funkcijas arī var vienkāršot (process saucas eta reduction):</p>
                    <pre>map (^2) [1, 2, 3, 4, 5]</pre>
                    <p>Lambda funkcijas ar vairakiem argumentiem veidojas līdzīgi: (\a b -> a + b)</p>
                </div>
                <div class="slide">
                    <h2>Uzdevumi</h2>
                    <p>Izveidojiet funkciju, kas izmanto foldl un apgriež rindu otrādi, bet šoreiz kā pirmo argumentu foldl izmantojiet lambda funkciju.</p>
                    <pre class="spoiler">foo line = foldl (\x y -> y : x) "" line</pre>
                    <p>Izveidojiet funkciju, kas izfiltrē visas patskaņas (a, e, i, o, u) no rindas, izmantojot anonīmo funkciju.</p>
                    <pre class="spoiler">foo line = filter (\x -> not $ elem x "aeiouAEIOU") line</pre>
                </div>
                <div class="slide">
                    <h2>Karings</h2>
                    <p>Karings ir process, kas pārveido funkciju ar vairākiem argumentiem par virkni funkciju ar vienu argumentu. Matemātiskās funkcijas var izmantot tikai vienu argumentu,
                        un tīri funkcionālās valodās funkcijām ir jāatbilst šim noteikumam. Bet, lai atvieglotu programmētāja darbu, tika izveidots mehānisms,
                        kas ļauj veidot funkcijas ar vairākiem argumentiem, nepārkāpjot tīri funkcionālo principu.</p>
                    <p>Piemēram, mēs gribam uztaisīt funkciju foo a b = a + b. Pirmkārt, pierakstīsim šo funkciju prefix pierakstā - foo a b = (+) a b. Tālāk izdomāsim funkciju (x -> x + a). Mēs redzam, ka šo funkciju mēs varam ievietot mūsu galvenajā funkcijā: foo a b = (x -> x + a) b. Un, līdzīgi kā iepriekš, ar eta reduction vienkāršosim to funkciju: foo a b = (+a) b</p>
                    <p>Šis process saucās karings (currying, no matemātiķa <a href="https://en.wikipedia.org/wiki/Haskell_Curry" target="_blank" class="link">Haskell Curry</a> uzvārda). To dara Haskell kompilators katru reizi, kad tiek izveidota funkcija ar vairākiem parametriem.</p>
                    <p>Tieši tāpēc Haskell izmanto tādus tipu pierakstus - tie demonstrē, kā funkcijas reducējas līdz vienam mainīgajam.</p>
                </div>
                <div class="slide">
                    <h2>Kompozīcijas</h2>
                    <p>Kompozīcija ir process, ar kura palīdzību divas funkcijas tiek salīmētas vienā. Kompozīciju operators ir (.), piemēram, foo . bar. Piemērs:</p>
                    <pre>import Data.Char

cap []     = ""
cap (x:xs) = toUpper x : xs

capWords = map cap . words

processString = unwords . capWords

main = print (processString "hello world")</pre>
                    <p>Kompozīcijas noder, lai savienotu funkcijas, kas bieži atkārtojas. Kā arī ar kompozīcijām var uzrakstīt lasāmāku kodu.</p>
                </div>
                <div class="slide">
                    <h2>Aplikācijas</h2>
                    <p>Aplikācija ir vienkāršs process, kad vienas funkcijas arguments ir citas funkcijas rezultāts. Piemēram, foo(bar 1).</p>
                    <p>Haskell valodā ir izveidots speciāls operators aplikācijām, ($). Piemēru augstāk var pierakstīt šādi: foo $ bar 1. Viss, kas no labās puses, tiek padots kā arguments funkcijai no kreisās puses.</p>
                    <p>Visas iepriekš attēlotās programmas var vienkāršot, izmantojot aplikācijas operatoru, piemēram:</p>
                    <pre>a % b = a / b * 100

main = do
    print $ 20 % 160
    print $ (%) 20 160</pre>
                </div>
                <div class="slide">
                    <h2>Kompozīcijas un aplikācijas operatori</h2>
                    <p>Lai saprastu līdz galam, kā darbojas šie operatori, varat izpētīt to kodus.</p>
                    <p>Aplikācijas operators:</p>
                    <pre>($) :: (a -> b) -> a -> b
f $ x = f x</pre>
                    <p>Kompozīcijas operators:</p>
                    <pre>(.) :: (b -> c) -> (a -> b) -> a -> c
(f . g) x = f (g x)</pre>
                </div>
                <div class="slide">
                    <h2>Uzdevumi</h2>
                    <p>Izveidojiet funkciju, kas ieceļ kvadrātā katru saraksta elementu, pirms tam izfiltrējot no ta visus nepāra skaitļus (funkcija even ir preteja funkcijai odd). Izveidojiet divas versijas funkcijai - vienu ar aplikācijas operatoru, otru ar kompozīcijas operatoru. Izmantojiet funkcijas map un filter.</p>
                    <pre class="spoiler">foo list = map (^2) $ filter even list</pre>
                    <pre class="spoiler">foo = map (^2) . filter even</pre>
                </div>
                <div class="slide">
                    <h2>Lazy</h2>
                    <p><em>Lazy</em> ir programmēšanas princips, kas atliek funkcijas izpildi līdz brīdim, kad tas ir vajadzīgs. Apskatīsim piemēru ar bezgalīgu sarakstu:</p>
                    <pre>main = print $ fst ([1 ..], 0)</pre>
                    <p>Jūs redzēsiet, ka tas tiešām ģenerē bezgalīgu sarakstu. Tagad ņemsim otro pāra elementu:</p>
                    <pre>main = print $ snd ([1 ..], 0)</pre>
                    <p>Tiks izvadīta nulle un programma beigs savu darbu. Saraksts nav sācis ģenerēties, jo tas nav vajadzīgs.</p>
                </div>
                <div class="slide">
                    <h2>Lazy piemēri</h2>
                    <p>Cits, nedaudz noderīgāks <em>lazy</em> pielietojums:</p>
                    <pre>main = print $ take 5 [1 ..]</pre>
                    <p>Mēs atkal izmantojam bezgalīgu sarakstu un pat sākam to ģenerēt. Bet augstākas kārtas funkcija take (paņemt n elementus no saraksta) kontrolē saraksta ģenerāciju. Kods saprot, ka vajag ģenerēt tikai 5 elementus, jo vairāk elementi programmā netiks izmantoti.</p>
                    <p>Vēl viens piemērs:</p>
                    <pre>mapOdds f = map f [1,3 ..]

main = print $ take 10 $ mapOdds (^2)</pre>
                    <p>Tiks aprēķināti kvadrāti pirmajiem 10 nepāra skaitļiem.</p>
                </div>
                <div class="slide">
                    <h2>Lazy un rekursīvie dati</h2>
                    <p>Haskell definē datus līdzīgi kā funkcijas:</p>
                    <pre>ones :: [Integer]
ones = [1, 1 ..]</pre>
                    <p>Šis ir bezgalīgs saraksts ar vieniniekiem, kuru, pateicoties lazy izpildei, mēs varam kontrolēt ar augstākas kārtas funkcijām. Bet šo pašu sarakstu var nodefinēt rekursīvi:</p>
                    <pre>ones = 1 : ones</pre>
                    <p>Pateicoties karingam, Haskell ļauj izveidot rekursīvus datus, jo šo var uzskatīt par funkciju ar 0 argumentiem (ones tipa aprakstā nav neviens "->" simbols jeb karinga operators).</p>
                    <p>Cits piemērs:</p>
                    <pre>odds = 1 : map (+2) odds</pre>
                    <p>Šis kods ģenerēs bezgalīgu sarakstu ar nepāra skaitļiem.</p>
                </div>
                <div class="slide">
                    <h2>Savstarpējas rekursijas</h2>
                    <p>Haskell ļauj izveidot savstarpēji rekursīvas funkcijas vai datus. Piemērs:</p>
                    <pre>odds, evens :: [Integer]
odds  = map succ evens
evens = 0 : map succ odds

main = print $ take 10 odds</pre>
                    <p>Funkcija succ palielina argumentu par 1.</p>
                    <p>Šeit mēs redzam, ka abi sarakstu ģeneratori izmanto viens otru. Nulle evens generatoram kalpo kā atskaites punkts.</p>
                </div>
                <div class="slide">
                    <h2>Savstarpējas rekursijas</h2>
                    <p>Nākamajā piemērā izveidosim bezgalīga pirmskaitļu saraksta ģeneratoru, kas ģenerēšanai izmantos funkciju, bet tā funkcija savukārt izmantos šo ģeneratoru:</p>
                    <pre>primes = 2 : filter isPrime [3, 5 ..]

isPrime n = all checkRem $ takeWhile checkSquare primes
    where
        checkRem    x = n `rem` x /= 0
        checkSquare x = x ^ 2 <= n

main = do
    print $ isPrime 37
    print $ take 10 primes</pre>
                    <p>Konstrukcija all checkRem pārbauda, vai visi saraksta elementi nedalās ar skaitli n. Savukārt takeWhile checkSquare atlasa elementus no saraksta, kamēr tie ir mazāki vai vienādi ar kvadrātsākni no n (kas ir pietiekami, lai pārbaudītu pirmskaitli). Funkcija rem atrod atlikumu no dalīšanas. Operators /= atgriež True, ja argumenti nav vienādi (!= citās valodās). Ar where var definēt lokālas funkcijas, kurām ir pieejami parent funkcijas argumenti.</p>
                </div>
                <div class="slide">
                    <h2>List comprehension</h2>
                    <p>List comprehension (LC) ir mehanisms, kas ļauj ģenerēt sarakstus izmantojot kādu citu sarakstu, funkciju un noteikumus. Vienkāršs piemērs:</p>
                    <pre>odds = [ x | x <- [1, 3 ..]]</pre>
                    <p>Šajā sarakstā būs visi nepāra skaitļi. LC ļauj izpildīt arī funkciju uz katra elementa, kā arī var būt definēti lokālie mainīgie, piemēram:</p>
                    <pre>list = [ y ^ 2 | x <- [1 .. 20], let y = x * 2]</pre>
                    <p>Šis saraksts saturēs kvadrātus skaitļiem no 1 līdz 20, reizinātiem ar 2.</p>
                    <p>LC var arī saturēt pārbaudes funkciju. Izmainīsim pēdējo piemēru, ņēmot tikai skaitļus, kuri dalās ar 3:</p>
                    <pre>list = [ y ^ 2 | x <- [1 .. 20], let y = x * 2, x `rem` 3 == 0]</pre>
                </div>
                <div class="slide">
                    <h2>Tipi un GHCi</h2>
                    <p>Pirms laika mēs iemācījamies, kā Haskell valodā tiek pierakstīti tipi funkcijām un datiem. Tagad ir laiks iepazīt Haskell tipu sistēmu padziļināti. Pirmkārt ir jāsaprot, ka Haskell valodā tips ir ne tikai funkcijām un datiem, bet jebkurai izteiksmei. Haskell programmētājam ir svarīgi būt spējīgam izprast, uz kādu tipu reducējas izteikums. Sākumā to ir grūti darīt galvā, tāpēc ir svarīgi apgūt GHCi.</p>
                    <p>Jebkuras izteiksmes tipu var pārbaudīt ar :t komandu. Palaidiet GHCi un uzrakstiet:</p>
                    <pre>λ> :t succ</pre>
                    <p>Šeit un turpmāk, komandas un izteikumi, kurus ir jāizpilda GHCi, tiks atzīmētas ar "λ> " prefiksu.</p>
                    <p>Jūs redzēsiet atbildi succ :: Enum a => a -> a. Tagad, ja izpildīsiet:</p>
                    <pre>λ> :t succ 1</pre>
                    <p>atbilde būs succ 1 :: (Enum a, Num a) => a. Mēģināsim analizēt abus rezultātus lai saprastu, kāpēc tie atšķirās.</p>
                </div>
                <div class="slide">
                    <h2>Izteikumu tipi</h2>
                    <p>Funkcija succ, kā mēs atceramies, palielina argumentu par 1. Tās tips ir</p>
                    <pre>Enum a => a -> a</pre>
                    <p>Šajā gadījumā a ir tipu mainīgais. Tipu mainīgie tiek izmantoti, lai atvieglotu tipa pierakstu. Tipu mainīgie ir aprakstīti pirms => zīmes. Mums patreiz ir svarīga konstrukcija pēc => zīmes, tas ir a -> a. Tas nozīmē, ka tiek paņemts arguments ar kaut kādu tipu un tiek atgriezta vērtība ar tādu pašu tipu.</p>
                    <p>Savukārt, izteikumam succ 1 tips ir</p>
                    <pre>(Enum a, Num a) => a</pre>
                    <p>, vai ignorējot visu pirms => zīmes - vienkārši a. Tas ir tāpēc, ka mēs jau padevam argumentu. Šim izteikumam vairs nevajag padot argumentus, jo tam ir noteikts rezultāts ar tipu a. Citiem vārdiem, šis izteikums reducējas uz noteikto rezultātu.</p>
                    <p>Jūs pamanījāt, ka mēs pagaidām ignorējam Enum un Num prefiksus. Tās ir tipu klases, un pie tām mēs nonāksim drīz. Bet pirms tam mēs izskatīsim vēl vienu piemēru izteikumu tipiem.</p>
                </div>
                <div class="slide">
                    <h2>Vēl nedaudz par izteikumu tipiem</h2>
                    <p>Izskatīsim piemērus ar funkciju map:</p>
                    <pre>λ> :t map
map :: (a -> b) -> [a] -> [b]

λ> :t map (+2)
map (+2) :: Num b => [b] -> [b]

λ> :t map (+2) [1..5]
map (+2) [1..5] :: (Enum b, Num b) => [b]</pre>
                    <p>Pirmajā mēs redzam standarta map definīciju, kas der jebkādiem tipiem. Otrajā mēs redzam, ka pazūda (a -> b) no tipa, jo mēs jau padevam funkciju (+2). Tips ir [b] -> [b]. Kāpēc ne [a] -> [b] - tāpēc, ka Haskell saprot, ka (+2) funkcija atgriež tādu pašu tipu, kas bija padots, par ko var pārliecināties, izpildot λ> :t (+2). Savukārt, trešais piemērs jau reducējas uz noteiktu rezultātu, tāpēc tips iz vienkārši [b].</p>
                    <p>Mēs redzam, ka katrā rindā tipu mainīgājiem parādās jaunās tipu klases. Intuitīvi var saprast, ka tās klases ievieš ierobežojumus uz iespējamiem argumentiem. Jūs varat salīdzināt, kā izmainīsies tipu apraksti, ja (+2) vietā tiktu izmantota funkcija sqrt (aprēķināt kvadrātsakni).</p>
                </div>
                <div class="slide">
                    <h2>Uzdevumi</h2>
                    <p>Neizmantojot GHCi, pamēģiniet paši uzrakstīt tipu funkcijai</p>
                    <pre>filter (\x -> not $ elem x "aeiou") . map toUpper</pre>
                    <pre class="spoiler">[Char] -> [Char]</pre>
                    <p>Neizmantojot GHCi, pamēģiniet paši uzrakstīt tipu izteiksmei</p>
                    <pre>[(a, b) | a <- [1..10], let b = a^2]</pre>
                    <pre class="spoiler">(Enum t, Num t) => [(t, t)]</pre>
                </div>
                <div class="slide">
                    <h2>Tipu klases</h2>
                    <p>Tipu klašu koncepts ir līdzīgs OOP konceptam <u class="def" id="interface">interface</u>. Tas apraksta, kādas darbības var veikt ar tipa vērtībām. Piemēram, salīdzināšanas funkcijas (==) tips ir Eq a => a -> a -> Bool. Mēs redzam tipu klasi Eq. Pie tās klases pieder visi tipi, kuru vērtības var salīdzināt. Tā, ka tipu mainīgais ir vienāds abiem argumentiem, mēs varam lasīt šo pierakstu šādi: funkcija (==) saņem divus argumentus vienāda tipa <em>a</em> un atgriež Bool, pie tam tipam <em>a</em> ir jāimplementē tipu klasi Eq.</p>
                    <p>Funkcija, kas pārbauda, vai viens arguments ir lielāks par otru - (>), kurās tips ir Ord a => a -> a -> Bool. Ord klase apvieno tos tipus, kuru vērtības var būt lielākas vai mazākas par citām tāda paša tipa vērtībām.</p>
                    <p>Iepriekš izmantotās funkcijas (+2) tips ir Num a => a -> a. Num klase apvieno tipus, ar kuriem var veikt aritmetiskās operācijas.</p>
                    <p>Saraksta [1, 2, 3, 4, 5] tips ir Num t => [t]. Savukārt, saraksta [1 .. 5] tips ir (Enum t, Num t) => [t]. Tas nozīmē, ka tipam <em>t</em> ir jāimplementē gan Num, Gan Enum tipu klases. Enum apvieno visus tipus, kuru vērtības ir sakārtotas, un tās var izmantot ģeneratoros, piemēram [1 .. 10] vai ['a' .. 'z']. Tagad mēs saprotam, ka funkcija succ patiesībā atgriež nākamo vērtību tipam, kas implementē Enum - succ 'a' atgriež 'b'.</p>
                    <p>Haskell ļauj veidot savus tipus, tipu klases, kā arī tipu klases var mantot īpašības no citām tipu klasēm.</p>
                </div>
                <div class="slide">
                    <h2>Tipu klašu veidošana</h2>
                    <p>Haskell ļauj veidot savas tipu klases. Kā piemēru izskatīsim Eq tipu klases definīciju:<p>
                    <pre>class  Eq a  where
    (==), (/=)            :: a -> a -> Bool
    x /= y                =  not (x == y)</pre>
                    <p>Šeit mēs redzam, ka ir nodefinēta tipu klase, kurai ir divas iespējamas darbības. Pie tam, darbībai (==) ir aprakstīts tikai tips, bet darbībai (/=) - gan tips, gan kods. Kāpēc tas ir definēts tiešī šādi - jo salīdzināšanas funkcija var atšķirties dažādiem tipiem. Savukārt darbība (/=) vienmēr ir preteja darbībai (==), tāpēc mēs varam uzreiz nodefinēt tās kodu.</p>
                    <p>Lai aprakstītu kodu darbībai ar konkrētu tipu tiek izmantots atslēgvārds instance:</p>
                    <pre>instance Eq Integer where
    x == y                =  x `integerEq` y

instance Eq Float where
    x == y                =  x `floatEq` y</pre>
                    <p>Var iztēloties, ka piemēram sarakstiem šī funkcija būs krietni sarežģītāka un rekursīva.</p>
                </div>
                <div class="slide">
                    <h2>Tipu klašu īpašību mantošana</h2>
                    <p>Haskell valodā tipu klases var mantot īpašības no citām tipu klasēm. Piemēram, Ord klase manto visu no Eq klases, un Ord klasei ir aprakstītas papildus īpašības:</p>
                    <pre>class  (Eq a) => Ord a  where
    (<), (<=), (>=), (>) :: a -> a -> Bool
    max, min             :: a -> a -> a</pre>
                    <p>Klašu darbību tipiem ir tāds pats apraksts, kā jebkurai funkcijai. Tas nozīmē, ka darbībai var aprakstīt ierobežojumus izmantojot klases:</p>
                    <pre>class Foo a where
    foo         :: Bar b => a -> b</pre>
                    <p>Kā var redzēt, ierobežojums ir aprakstīts rezultātam. Savukārt, ierobežojumi argumentiem ir aprakstami ar klašu mantošanu vai ar instancēm.</p>
                    <p>Klases var mantot īpašības no vairākām klasēm:</p>
                    <pre>class (Foo a, Bar a) => Baz a where</pre>
                </div>
                <div class="slide">
                    <h2>Tipu veidošana</h2>
                    <p>Haskell ļauj programmētājam veidot savus tipus, aprakstot iespējamas vērtības:</p>
                    <pre>data Foo = A | B | C | D</pre>
                    <p>Šis ir tips, kuram iespējamas vērtības ir A, B, C un D. Šobrīd ar šo tipu nevar neko darīt, jo tas neimplementē nekādu darbību. Pat, ja mēģināt izprintēt jebkādu vērtību, tiek parādīts error "No instance for (Show Foo) arising from a use of `print'". Tas nozīmē, ka šim tipam vajag mantot darbības no tipu klases Show, lai būtu iespēja izvadīt vērtības. Salabosim to:</p>
                    <pre>data Foo = A | B | C | D
    deriving (Show)

main = print A</pre>
                    <p>Ar derive atslēgvārdu mēs pateicam kompilatoram, ka tips Foo tagad pieder pie Show tipu klases. Šī klase apvieno visus tipus, kurus var izvadīt.</p>
                </div>
                <div class="slide">
                    <h2>Tipu veidošana</h2>
                    <p>Papētīsim mūsu tipu vēl nedaudz. Mēs redzam, ka B iet pēc A, un mēs gribētu, lai izteiksme succ A atgrieztu B. Sākumā pārbaudīsim succ tipu:</p>
                    <pre>λ> :t succ
succ :: Enum a => a -> a</pre>
                    <p>Redzam, ka succ argumentam ir jābūt no Enum tipu klases. Papildinam mūsu tipu ar to:</p>
                    <pre>data Foo = A | B | C | D
    deriving (Show, Enum)

main = do
    print $ succ A
    print [A .. D]</pre>
                    <p>Kā var saprast no piemēra, ģenerators [A .. D] arī pieprasa, lai tips būtu no Enum klases.</p>
                </div>
                <div class="slide">
                    <h2>Tipu konstruktori</h2>
                    <p>Haskell ļauj veidot sarežģītākus, augstākās kārtas tipus, kuri sastāv no vairākām vērtībām. Pie tam, to vērtību skaits arī var būt atšķirīgs. Izveidosim tipu, kas apraksta transportlīdzēkļus - velosipēdiem būs parametri nosaukums un riteņu diametrs, savukārt mašīnām - nosaukums, riteņu diametrs un dzinēja tilpums.</p>
                    <pre>data Vehicle = Bicycle String Integer | Car String Integer Float
    deriving (Show)

main = print $ Bicycle "Kross" 26</pre>
                    <p>Šeit Vehicle ir tipa konstruktors, savukārt Bicycle un Car ir vērtības konstruktori.</p>
                    <p>Mēs redzam, ka abiem konstruktoriem ir kopējie elementi - nosaukums un riteņu diametrs. Izdalīsim tos atsevišķajā tipā:</p>
                    <pre>data Transport = Transport String Integer deriving (Show)
data Vehicle = Bicycle Transport | Car Transport Float
    deriving (Show)

main = print $ Car (Transport "Ford" 16) 2.0</pre>
                </div>
                <div class="slide">
                    <h2>Record pieraksts</h2>
                    <p>Mēs iemācījamies veidot augstākās kārtas tipus, bet pamanījām ļoti nopietnu trūkumu - vērtībām nav nosaukumu, un mēs nevaram saprast, ko konkrēta vērtība nozīmē. Haskell ļauj izmantot Record pierakstu, kas ir pārskatamāks:</p>
                    <pre>data Vehicle = Bicycle {name :: String, wheelSize :: Integer}
    | Car {name :: String, wheelSize :: Integer, engine :: Float}
    deriving (Show)

main = print $ Car {
    name = "Ford",
    wheelSize = 16,
    engine = 2.0
}</pre>
                </div>
                <div class="slide">
                    <h2>Tipu parametri</h2>
                    <p>Haskell ļauj neprecizēt konkrētus tipus konstruktorā, tajā vietā var izmantot tipu parametrus.</p>
                    <pre>data Car a b c = Car {name :: a, wheelSize :: b, engine :: c}
    deriving (Show)

main = do
    print $ Car {
        name = "Ford",
        wheelSize = 16,
        engine = 2.0
    }
    print $ Car {
        name = "Ford",
        wheelSize = "16 inches",
        engine = "2.0 litres"
    }</pre>
                    <p>Lielāka priekšrocība ir tas, ka veidojot finkciju, kas strādā ar šiem tipiem, mēs neesam piesieti pie konkrētiem zemākas kārtas tipiem.</p>
                </div>
                <div class="slide">
                    <h2>Maybe konstruktors</h2>
                    <p>Viens no populārākiem veidiem, kā tiek izmantoti tipu parametri, ir Maybe tipa konstruktors, kas tiek izmantots gadījumos, kad mainīgais var nepastāvēt:</p>
                    <pre>data Maybe a = Nothing | Just a</pre>
                    <p>To var izmantot šādi:</p>
                    <pre>foo :: Integral a => a -> Maybe a
foo x = if even x
            then Just (x `div` 2)
            else Nothing

main = do
    print $ foo 5
    print $ foo 6</pre>
                    <p>Pateicoties tipa parametram tiek panākts tas, ka Maybe var būt jebkāda tipa - Maybe Int, Maybe [Float], Maybe Car utt.</p>
                </div>
                <div class="slide">
                    <h2>Uzdevumi</h2>
                    <p>Izveidojiet kvadrātsakņes (sqrt) funkciju, kas atgriež Nothing, ja skaitlis ir negatīvs.</p>
                    <pre class="spoiler">mySqrt n
    | n >= 0    = Just $ sqrt n
    | otherwise = Nothing

main = do
    print $ mySqrt 16
    print $ mySqrt (-5)</pre>
                </div>
                <div class="slide">
                    <h2>Funktori</h2>
                    <p>Haskell valodā nopietnu lomu spēlē tipu klase Functor. Tā apvieno visus tipu konstruktorus, kuriem ir implementēta funkcija fmap:</p>
                    <pre>class Functor f where
    fmap :: (a -> b) -> f a -> f b</pre>
                    <p>Pats Functor klases apraksts ir ļoti interesants. Pirmkārt, mēs redzam, ka ja agrāk mēs izmantojam klases parametru kā tipu, tad šeit <em>f</em> tiek izmantots kā tipu konstruktors.</p>
                    <p>Otrkārt, mēs redzam, ka fmap funkcijai ir divi atribūti. Pirmais ir funkcija, kas pieņem tipu <em>a</em> un atgriež tipu <em>b</em>. Savukārt, otrs arguments, ir tips <em>a</em>, bet ar tipa konstruktoru <em>f</em>, un fmap rezultātam ir tips <em>b</em> ar kontekstu <em>f</em>. Var saprast, ka fmap ir domāta, lai izņemtu vērtību tipa <em>a</em> no <em>f</em>, izpildītu funkciju (a -> b) izmantojot to vērtību, un rezultātu iepakot atpakaļ <em>f</em> kontekstā.</p>
                    <p>Skaidrs, ka šo saprast var būt grūti, tāpēc turpināsim ar piemēriem.</p>
                </div>
                <div class="slide">
                    <h2>Funktoru piemēri</h2>
                    <p>Paņemsim mums zināmu konstruktoru Maybe. Ja mums ir tips Maybe Int un vērtība piemēram Just 5, mēs nevaram izdarīt operacijas, kuras parasti ir pieejamas ar tipu Int. Šis kods izsauks kļūdu:</p>
                    <pre>λ> (+2) $ Just 5</pre>
                    <p>Bet mēs zinam, ka fmap var atbrīvot vērtību no datu konstruktora konteksta un izpildīt funkciju, kas var strādāt ar šo tipu:</p>
                    <pre>λ> fmap (+2) $ Just 5
Just 7
λ> fmap (+2) $ Nothing
Nothing</pre>
                    <p>Lai saprastu, kā tas strādā, var apskatīties Funktor instanci Maybe konstruktoram:</p>
                    <pre>instance Functor Maybe where
    fmap func (Just val) = Just (func val)
    fmap func Nothing = Nothing</pre>
                </div>
                <div class="slide">
                    <h2>Funktoru piemēri</h2>
                    <p>Cits mums zināms piemērs vērtībai, kas ir iepakota kontekstā, ir saraksti. Tiešām, [Int] ir nekas cits, ka datu konstruktors. Tas varēja izskatīties List Int, bet [Int] cukurs ir ērtāks. Ja mēs atcerēsimies fmap aprakstu:</p>
                    <pre>fmap :: (a -> b) -> f a -> f b</pre>
                    <p>un iztēlosimies, ka f a un f b vietā ir attiecīgi [a] un [b], tad mēs redzēsim, ka fmap tips sarakstiem ne ar ko neatšķirās no map funkcijas apraksta:</p>
                    <pre>(a -> b) -> [a] -> [b]</pre>
                    <p>Tāpēc nav nekāds pārsteigums, ka Functor instance sarakstiem izskatās šādi:</p>
                    <pre>instance Functor [] where
    fmap = map</pre>
                    <p>par ko ir viegli pārliecināties:</p>
                    <pre>λ> fmap (+2) [1 .. 5]
[3,4,5,6,7]</pre>
                </div>
                <div class="slide">
                    <h2>Monādes</h2>
                    <p>Daudzi ir dzirdējuši par monādēm un ka to konceptu ir grūti izprast. Bet ar esošām zināšanām par tipu sistēmu Haskellā Jums pietiks, lai viegli apgūtu šo konceptu.</p>
                    <p>Patreiz Jūs jau zināt, ka Functor tipu klase "izpako" vērtību no konteksta, padod to funkcijai bez kontekstiem un rezultātu "iepako" atpakaļ. Tagad izdomāsim, ka mums ir nepieciešama vienkāršāka funkcija - kas pieņem parasta tipa argumentu un iepako to kontekstā. Nosauksim to par return:</p>
                    <pre>return :: a -> m a</pre>
                    <p>Šīs funkcijas piemēri:</p>
                    <pre>λ> return 5 :: Maybe Int
Just 5
λ> return 5 :: [Int]
[5]</pre>
                    <p>Kā redzat, izteikuma tipu var definēt pēc izteikuma ar :: palīdzību</p>
                </div>
                <div class="slide">
                    <h2>Monādes</h2>
                    <p>Atgriežoties pie fmap funkcijas - tā izņēm vērtību no konteksta, padod to parastai funkcijai un pēc tam ieliek atpakaļ kontekstā. Bet ja mums ir funkcija, kas pati atgriež vērtību kontekstā? Teiksim, funkcija ar tipu a -> m b, līdzīgi funkcijai return. Un vēl, mēs gribam tai funkcijai padot vērtību kontekstā. Šim gadījumam palīdz funkcija (>>=) vai kā to pieņemts saukt - bind:</p>
                    <pre>(>>=) :: m a -> (a -> m b) -> m b</pre>
                    <p>Piemēri:</p>
                    <pre>λ> (>>=) (Just 5) (\x -> Just (x + 2))
Just 7
λ> (>>=) [5] (\x -> [x + 2])
[7]</pre>
                    <p>Pievērsiet uzmanību, ka (>>=) var ērti izmantot infix pierakstā:
                    <pre>λ> Just 5 >>= return  . (+2)
Just 7</pre>
                    <p>Patreiz Jūms tas var nebūt acīmredzami, bet (>>=) funkcijai ir milzīgs pielietojums Haskell valodā.</p>
                </div>
                <div class="slide">
                    <h2>Monādes</h2>
                    <p>Ir tipu klase, kas sevī apvieno abas šīš funkcijas. Tā tipu klase saucās Monad. Tās definīcija iekļauj sevī vēl pāris papildus funkcijas, bet bind un return ir galvēnas.</p>
                    <p>Izpētīsim Monad klases definīciju:</p>
                    <pre>infixl 1  >>, >>=
class  Monad m  where
    (>>=)            :: m a -> (a -> m b) -> m b
    (>>)             :: m a -> m b -> m b
    return           :: a -> m a
    fail             :: String -> m a

    m >> k           =  m >>= \_ -> k</pre>
                    <p>(>>) ir (>>=) versija, kas ignorē argumentu - funkcija ir noderīga, lai būvētu virkni neatkarīgo operāciju. Piemēram, <em>do</em> notaciju var pārrakstīt šādi:</p>
                    <pre>main = print 1 >> print 2</pre>
                </div>
                <div class="slide">
                    <h2>Vēlreiz par funktoriem un monādēm</h2>
                    <p>Patreiz Jūms visticamāk ir liela putra, un Jūs jaucat funktorus, monādes un tā tālāk. Tāpēc izveidosim tabulas, lai atšķirtu Functor un Monad pamatfunkcijas - fmap, return un (>>=):</p>
                    <table class="description">
                        <tr>
                            <th></th>
                            <th>Pirmais arguments</th>
                            <th>Otrais arguments</th>
                            <th>Rezultāts</th>
                        </tr>
                        <tr>
                            <td>fmap</td>
                            <td>Funkcija ar tipu a -> b</td>
                            <td>Vērtība kontekstā: f a</td>
                            <td>Vērtība kontekstā: f b</td>
                        </tr>
                        <tr>
                            <td>(>>=)</td>
                            <td>Vērtība kontekstā: m a</td>
                            <td>Funkcija ar tipu a -> m b</td>
                            <td>Vērtība kontekstā: m b</td>
                        </tr>
                        <tr>
                            <td>return</td>
                            <td>Vērtība bez konteksta: a</td>
                            <td>-</td>
                            <td>Vērtībā kontekstā: m a</td>
                        </tr>
                    </table>
                    <p>Un vēlreiz funkciju tipi:</p>
                    <table class="description">
                        <tr>
                            <td>fmap</td>
                            <td>Functor f => (a -> b) -> f a -> f b</td>
                        <tr>
                        </tr>
                            <td>(>>=)</td>
                            <td>Monad m => m a -> (a -> m b) -> m b</td>
                        </tr>
                        <tr>
                            <td>return</td>
                            <td>Monad m => a -> m a</td>
                        </tr>
                    </table>
                </div>
                <div class="slide">
                    <h2>Vēlreiz par funktoriem un monādēm</h2>
                    <p>Tātad, lai tipu konstruktors (vai konteksts) varētu izmantot fmap, tam ir jābūt definētai Functor instancei. Savukārt, lai konteksts varētu izmantot (>>=) un return, tam ir jābūt definētai Monad instancei.</p>
                    <p>Mūsu zināmiem konstruktoriem Maybe un [] arī ir sarakstītas Monad instances:</p>
                    <pre>instance Monad [] where
    return x = [x]

    xs >>= f = concat (map f xs)


instance Monad Maybe where
    return x  = Just x

    (>>=) m g = case m of
                   Nothing -> Nothing
                   Just x  -> g x</pre>
                   <p>Turpmāk visus konstruktorus, kas implementē Monad klasi, mēs vienkārši sauksim par monādēm. Tātad, varam teikt, ka Maybe un [] ir monādes.</p>
                </div>
                <div class="slide">
                    <h2>IO Monāde</h2>
                    <p>Mēs jau zinām, kā izvadīt rindu - ar funkciju print. Tagad, kad mums ir zināšanas par monādēm un tipu klasēm, apskatīsimies funkcijas print tipu:</p>
                    <pre>λ> :t print
print :: Show a => a -> IO ()</pre>
                    <p>Mēs jau zinām, ka Haskell valodā katrai izteiksmei ir savs tips. Mēs redzam, ka funkcijas print rezultāta tips ir IO (). Mēs jau varam saprast, ka tas ir datu konstruktors IO ar vērtību (), kas ir tukšs pāris. Haskell valodā tukšs pāris bieži tiek izmantots, ka tukša vērtība.</p>
                    <p>IO datu konstruktors ir monāde. Tas nozīmē, ka tam ir implementēta Monad instance un ir sarakstīti kodi funkcijām return un (>>=). Konkrēti IO monādei šos kodus nevar attēlot ar Haskell kodu - tās ir realizētas zemākā līmeņa valodā. Bet lai darbotos ar šo monādi, tas nav nepieciešams - pietiek zināt funkciju nosaukumus.</p>
                </div>
                <div class="slide">
                    <h2>IO darbības</h2>
                    <p>IO darbības (IO actions) ir nosaukums, ar kuru tiek apzīmētas IO monādes funkcijas. Tās darbības atšķirās no citām ar to, ka tās izpildas uzreiz - tas ir, nestrādā Lazy princips. Izpētīsim vienkāršu programmu, kas izmantos IO darbības un funkciju cap, kuru sarakstījām nesen:</p>
                    <pre>import Data.Char

cap [] = ""
cap (x:xs) = toUpper x : xs

main = do
    putStrLn "Ievadiet rindu"
    str <- getLine
    (putStrLn . cap) str</pre>
                    <p>Konstrukciju str <- getLine var lasīt kā "izpildīt IO darbību getLine un piesaistīt tās rezultātam vārdu str". Pie tam, <- atbrīvo no konteksta, tas ir, str tips ir String, nevis IO String. Tāpēc zemāk mēs varam mierīgi to padot funkcijai cap, kuras argumenta tips ir String.</p>
                    <p>Tālāk mēs nedaudz paeksperimentēsim ar šo programmu, pielietojot monādiskās funkcijas.</p>
                </div>
                <div class="slide">
                    <h2>IO darbības</h2>
                    <p>Mūs interesē tipi katram izteikumam do notacijā. putStrLn "Ievadiet rindu" tips ir IO (). getLine tips ir IO String. Ja iztēloties, ka IO () ir m a, bet IO String ir m b, tad mēs redzam, ka abas izteiksmes var izmantot kā argumentus funkcijai (>>), kuras tips ir m a -> m b -> m b. Aizvietosim abas rindas ar:</p>
                    <pre>str <- putStrLn "Ievadiet rindu" >> getLine</pre>
                    <p>Izteiksmes putStrLn "Ievadiet rindu" >> getLine tips ir IO String, vai m a. Savukārt funkcijas (putStrLn . cap) tips ir String -> IO (), vai a -> m b. Atceramies funkcijas (>>=) tipu - m a -> (a -> m b) -> m b. Acīmredzami, ka mēs varam apvienot arī šīs rindas:</p>
                    <pre>putStrLn "Ievadiet rindu" >> getLine >>= putStrLn . cap</pre>
                    <p>Tā kā mums palika tikai viena rinda, mēs varam atbrīvoties no do notacijas:</p>
                    <pre>import Data.Char

cap [] = ""
cap (x:xs) = toUpper x : xs

main = putStrLn "Ievadiet rindu" >> getLine >>= putStrLn . cap</pre>
                </div>
                <div class="slide">
                    <h2>Uzdevumi</h2>
                    <p>Uzrakstiet programmu, kas ierakstītai rindai apgriež katru vārdu otrādi un aizvieto katru simbolu 'a' ar '4', 's' ar '5' un 'o' ar '0'. Uzrakstiet versiju ar do notaciju, pēc tam pārveidojiet to, izmantojot (>>) un (>>=) funkcijas. Izmantojiet funkcijas words un unwords.</p>
                    <pre class="spoiler">flipWord = foldl (\x y -> y : x) ""

replaceChar c
    | c == 'a' = '4'
    | c == 'o' = '0'
    | c == 's' = '5'
    |otherwise = c

processString = unwords . map (map replaceChar . flipWord) . words

main = do
    putStrLn "Izvadiet rindu"
    str <- getLine
    putStrLn $ processString str</pre>
                    <pre class="spoiler">putStrLn "Izvadiet rindu" >> getLine >>=  putStrLn . processString</pre>
                </div>
                <div class="slide">
                    <h2>Monādiskās funkcijas</h2>
                    <p>Šeit būs sarakstītas noderīgas funkcijas darbībām ar monādēm. Dažas funkcijas nāk noklusējuma pakā (Preludē), dažām ir jāveic atsevišķs Control.Monad imports.</p>
                    <p><b>(=<<)</b> - pretēja virziena bind funkcija. darbības principu var izprast no funkcijas definīcijas:</p>
                    <pre>f =<< x  =  x >>= f</pre>
                    <p><b>join (Control.Monad)</b> - noņem vienu konteksta līmeni, piemēram, m (m a) pārtop par m a. Funkcijas definīcija:</p>
                    <pre>join x  =  x >>= id</pre>
                    <p>Nedaudz par id funkciju - tā funkcija atgriež vērtību bez izmaiņām. Var teikt, ka tā funkcija neko nedara. Funkcijas id kods ir id x = x.</p>
                    <p>Interesants fakts par id funkciju - tā ir vienīga tīra funkcija, kuras tips ir a -> a, bez konteksta. Padomājiet, kāpēc tieši tā, kā arī padomājiet, kāpēc join definīcija ir tieši tāda.</p>
                    <p>Atgriežoties pie join - tās tips ir Monad m => m (m a) -> m a. Vēlreiz Jūs varat pamanīt, ka ar Haskell funkcijām bieži darbības principu var saprast, izpētot tās tipu.</p>
                </div>
                <div class="slide">
                    <h2>Monādiskās funkcijas</h2>
                    <p><b>liftM (Control.Monad)</b> - Pārveidot funkciju a -> b par m a -> m b. Piemēram, mēs padodam funkciju sqrt, izteikuma liftM sqrt rezultāts būs jauna funkcija ma -> mb. Kā var noprot, šī jauna funkcija pieņem vērtību kontekstā un atgriež vērtību kontekstā. Piemērs:</p>
                    <pre>λ> (liftM sqrt) (Just 5)
Just 2.23606797749979</pre>
                    <p>Funkcijas liftM definīcija:</p>
                    <pre>liftM :: Monad m => (a1 -> r) -> m a1 -> m
liftM f m1 = do
    x1 <- m1
    return (f x1)</pre>
                    <p><b>liftM2 (Control.Monad)</b> - pārveido funkciju tipa a -> b -> c par m a -> m b -> m c:</p>
                    <pre>liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
liftM2 f m1 m2 = do
    x1 <- m1
    x2 <- m2
    return (f x1 x2)</pre>
                </div>
                <div class="slide">
                    <h2>Monādiskās funkcijas</h2>
                    <p>Eksistē arī liftM3, liftM4 un liftM5:</p>
                    <pre>
liftM3 :: Monad m =>
            (a1 -> a2 -> a3 -> r)
            -> m a1 -> m a2 -> m a3 -> m r

liftM4 :: Monad m =>
            (a1 -> a2 -> a3 -> a4 -> r)
            -> m a1 -> m a2 -> m a3 -> m a4 -> m r

liftM5 :: Monad m =>
            (a1 -> a2 -> a3 -> a4 -> a5 -> r)
            -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r</pre>
                </div>
                <div class="slide">
                    <h2>Monādiskās funkcijas</h2>
                    <p><b>ap (Control.Monad)</b> - noder ja mums ir funkcija monādē, piemēram m (a -> b), un vērtība monādē m a. Rezultāts ir tajā pašā monādē - m b.</p>
                    <pre>ap :: Monad m => m (a -> b) -> m a -> m b
ap = liftM2 id</pre>
                    <p>Piemērs:</p>
                    <pre>λ> ap (Just (+2)) (Just 3)
Just 5
λ> ap [(+2), (^2)] [3,4]
[5,6,9,16]</pre>
                    <p>Ap noder kā aizvietojums liftMn funkcijām: liftMn f x1 x2 .. xn = return f `ap` x1 `ap` x2 `ap` .. `ap` xn.</p>
                </div>
                <div class="slide">
                    <h2>Uzdevumi</h2>
                    <p>Uzrakstiet funkciju, kas pārveido sarakstu [[1], [2], [3, 4], [5]] par [1, 2, 3, 4, 5], izmantojot monādiskās funkcijas.</p>
                    <pre class="spoiler">myConcat l = join l</pre>
                    <p>Izveidojiet map funkcijas analogu, izmantojot monādiskās funkcijas.</p>
                    <pre class="spoiler">myMap f = liftM f</pre>
                    <p>Izmantojot monādiskās funkcijas, uzrakstiet funkciju, kas sasumē katru saraksta elementu ar katru otra saraksta elemenu. Piemēram mySum [2, 3] [5, 6] - [7, 8, 8, 9]</p>
                    <pre class="spoiler">let mySum l1 l2 = liftM2 (+) l1 l2</pre>
                </div>
                <div class="slide">
                    <h2>Uzdevumi</h2>
                    <p>Uzrakstiet funkcijas liftM4 kodu.</p>
                    <pre class="spoiler">
liftM4 f m1 m2 m3 m4 = do
    x1 <- m1
    x2 <- m2
    x3 <- m3
    x4 <- m4
    return (f x1 x2 x3 x4)</pre>
                    <p>Uzdevums, kas neattiecās uz monādiskām funkcijām, bet ir domāts, lai pārbaudītu visu, kas ir iemācīts iepriekš. Izveidojiet programmu, kas saņem rindu ar vairākiem skaitļiem un izvada katra skaitļa ciparu summu, piemēram "1234 5678" -> "10 26". Izmantojiet funkcijas read un show konvertācijai uz un no Integer, un funkciju sum, lai sasumētu visus saraksta skaitļus. Izmantojiet (>>) un (>>=), neizmantojiet do notaciju. Nevienā funkcijā nedrikst būt norādīti argumenti - izmantojiet eta reduction visur, piemēram nevis "foo l = map func l", bet "foo = map func".</p>
                    <pre class="spoiler">toInt = read . return

sumDigits = map (show . sum . map toInt) . words

main = putStrLn "Ievadiet skaitļus" >> getLine >>= putStrLn . unwords . sumDigits</pre>
                </div>
            </div>
        </div>
        <div class="tryit">
            Try-it editor, coming soon...
        </div>
    </div>
    <div id="tooltip">
        <div id="tooltip_functional" class="tooltip">Funkcionālās valodas ir valodas, kas izpilda programmu līdzīgi matemātiskai funkcijai, neizmantojot stāvokli un mainīgus datus.</div>
        <div id="tooltip_imperative" class="tooltip">Imperatīvās valodas ir valodas, kas veido programmu kā sarakstu ar soļiem, un pēc katra soļa mainās programmas stāvoklis.</div>
        <div id="tooltip_compiler" class="tooltip">Kompilators ir programma, kas pārveido kodu, uzrakstītu programmēšanas valodā, par kodu, kuru var izpildīt dators.</div>
        <div id="tooltip_pure" class="tooltip">Tīri funkcionāla valoda ir valoda, kurā funkcijas nesatur blakus efektus. Tas nozīmē, ka funkcijas saņem argumentus, apstradā un atgriež rezultātu, un nedara neko citu - ne datu attēlošanu, ne saglabāšanu failos vai jebkādu citu darbību.</div>
        <div id="tooltip_oop" class="tooltip">Object Oriented valodas ir valodas, kas izmanto objektus kā valodas pamatelementus. Objekti sastāv no elementiem un metodēm.</div>
        <div id="tooltip_boilerplate" class="tooltip">Boilerplate ir daļa no koda, kuru gandrīz vienmēr vai vienmēr ir jāliek programmā.</div>
        <div id="tooltip_type" class="tooltip">Mainīgo vai argumentu tips programmēšanā nosaka, kādi dati var būt izmantoti ar šo mainīgo un kādas operācijas ir atļautas. Piemēram, skaitļu tipiem ir atļautas aritmētiskās operācijas.</div>
        <div id="tooltip_recursive" class="tooltip">Rekursīva funkcija ir funkcija, kas izsauc pati sevi.</div>
        <div id="tooltip_sugar" class="tooltip">Sintaktiskais atvieglojums jeb sintaktiskais cukurs ir kāda koda aizvietojums, kas padara to lasāmāku vai ērtāk izmantojamu.</div>
        <div id="tooltip_factorial" class="tooltip">Faktoriālis ir funkcija ar argumentu n, kuras rezultāts ir visu skaitļu no 1 līdz n reizinājums, piemēram, fact(5) = 1*2*3*4*5 = 120. Tiek pieņemta faktoriāļa definīcija: ja n ir 0, tad faktoriālis ir 1, citos gadījumos faktoriālis ir n reiz faktoriālis no n-1.</div>
        <div id="tooltip_interface" class="tooltip">Interface ir kaut kas līdzīgs klašu šablonam. Visās klasēs, kas implementē kādu interfeisu, ir jābūt nodefinetām visām īpašībām un metodēm, kas ir aprakstītas šablonā.</div>
    </div>
    <script type="text/javascript" src="index.js"></script>
</body>
</html>
